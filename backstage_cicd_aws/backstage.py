# from dotenv import dotenv_values
import json

from aws_cdk import (
    Stack
)
from aws_cdk import aws_ec2 as ec2
from aws_cdk import aws_ecr as ecr
from aws_cdk import aws_ecs as ecs
from aws_cdk import aws_iam as iam
from aws_cdk import aws_rds as rds
from aws_cdk import aws_ecs_patterns as ecs_patterns
from aws_cdk import aws_secretsmanager as secrets
from constructs import Construct


# from collections import OrderedDict


class BackstageStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, props: dict, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # CommonResourceStack
        # Create a VPC
        db_port = int(props.get("POSTGRES_PORT", 5432))
        container_name = props.get("CONTAINER_NAME", 'backstage')
        ecr_repo_name = props.get("ECR_REPO_NAME", "aws-cdk/assets")

        self.vpc = ec2.Vpc(
            self,
            "ECS-VPC",
            max_azs=2,
        )
        # Define SGs so Fargate and no-one else can talk to aurora securly
        self.fargate_sg = ec2.SecurityGroup(
            self, "fargate-sec-group",
            security_group_name="FargateSecGroup",
            description="Security group for Fargate Task",
            vpc=self.vpc
        )

        self.aurora_sg = ec2.SecurityGroup(
            self, "aurora-sec-group",
            security_group_name="AuroraSecGroup",
            description='Security group for Aurora Db',
            vpc=self.vpc
        )
        # default egress rules are for any, so we just need an ingress rule
        # to allow fargate to reach the aurora cluster and protect its access from elsewhere
        self.aurora_sg.add_ingress_rule(peer=self.fargate_sg, connection=ec2.Port.tcp(db_port))

        self.aurora_instance = rds.InstanceProps(
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),
            vpc=self.vpc,
            security_groups=[self.aurora_sg]
        )

        # We either create or pull in an ECR repo for the app pipeline and ECS to use.
        # on inital deploy of ECS no image will be found, but the app pipeline should build and push a new image
        if ecr_repo_name is None:
            self.image_repo = ecr.Repository(self, "repo", repository_name=container_name, image_scan_on_push=True)
        else:
            self.image_repo = ecr.Repository.from_repository_name(self, "repo", ecr_repo_name)

        # Now make the ECS cluster, Task def, and Service
        self.ecs_cluster = ecs.Cluster(self, "BackstageCluster", vpc=self.vpc)

        # lets create a named role so its easy to find and modify policies for
        # This is the role which enables the container access to AWS services.
        self.task_role = iam.Role(
            self,
            "fargate-task-role",
            role_name='Backstage-Fargate-Task-Role',
            assumed_by=iam.ServicePrincipal("ecs-tasks.amazonaws.com")
        )
        # StageResourceStack
        db_username = props.get("POSTGRES_USER", 'postgres')
        container_port = props.get("CONTAINER_PORT", '7000')
        self.secret_mapping = dict()
        # generate the json string for the secret with the .env username set

        secret_string = secrets.SecretStringGenerator(
            secret_string_template=json.dumps({"username": db_username}),
            generate_string_key="password",
            exclude_punctuation=True,
            include_space=False,
        )
        # generate and store password and username
        self.aurora_creds = secrets.Secret(
            self, 'AuroraCredentialsSecret',
            secret_name="backstagedbauth",
            generate_secret_string=secret_string
        )
        # replace the .env pg passwd generated one to share between ECS and Aurora
        # props['POSTGRES_PASSWORD'] = aurora_creds.secret_value_from_json('password').to_string()
        self.secret_mapping.update(
            {'POSTGRES_PASSWORD': ecs.Secret.from_secrets_manager(self.aurora_creds, field='password')})

        self.aurora_pg = rds.DatabaseCluster(
            self, "PGDatabase",
            engine=rds.DatabaseClusterEngine.aurora_postgres(version=rds.AuroraPostgresEngineVersion.VER_10_14),
            credentials=rds.Credentials.from_secret(self.aurora_creds),
            instance_props=self.aurora_instance,
            # subnet_group=db_subnet_group,
        )

        # set envar for DB hostname as generated by CFN
        props['POSTGRES_HOST'] = self.aurora_pg.cluster_endpoint.hostname

        # this builds the backstage container on deploy and pushes to ECR
        self.ecs_task_options = ecs_patterns.ApplicationLoadBalancedTaskImageOptions(
            image=ecs.ContainerImage.from_ecr_repository(self.image_repo),
            container_port=int(container_port),
            environment=props,  # pass in the env vars
            container_name=container_name,
            secrets=self.secret_mapping,
            task_role=self.task_role,
            enable_logging=False
        )

        # Easiest way to stand up mult-tier ECS app is with an ecs_pattern,  we are making it HTTPS
        # and accessible on a DNS name. We give ECS the Security Group for fargate
        self.ecs_stack = ecs_patterns.ApplicationLoadBalancedFargateService(self, "BackstageService",
                                                                            cluster=self.ecs_cluster,  # Required
                                                                            cpu=512,  # Default is 256
                                                                            desired_count=1,  # Default is 1
                                                                            memory_limit_mib=2048,  # Default is 512
                                                                            public_load_balancer=True,
                                                                            # Default is False
                                                                            security_groups=[self.fargate_sg],
                                                                            # put the task/cluster in the group we created
                                                                            task_image_options=self.ecs_task_options,
                                                                            # certificate=self.cert, #specifiying the cert enables https
                                                                            #redirect_http=True,
                                                                            # domain_name = fqdn,
                                                                            # domain_zone = self.hosted_zone,
                                                                            enable_ecs_managed_tags=True,
                                                                            )
